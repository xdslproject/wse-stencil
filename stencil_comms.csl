// color map of stencil_comms + memcpy:
//
// color  var             color  var          color  var              color  var
//   0                      9                  18    northDataFin      27   reserved (memcpy)
//   1                     10                  19    southDataFin      28   reserved (memcpy)
//   2                     11                  20    eastWestCtrlFin   29   reserved (memcpy)
//   3                     12                  21    reserved (memcpy) 30   reserved (memcpy)
//   4   eastChannel       13                  22    reserved (memcpy) 31   reserved
//   5   westChannel       14                  23    reserved (memcpy) 32
//   6   northChannel      15                  24    northSouthCtrlFin 33
//   7   southChannel      16    eastDataFin   25    eastWestFin       34
//   8                     17    westDataFin   26    northSouthFin     35
//

//
// FD uses input_queue = 4,5,6,7
// oned_exch.csl:    .input_queue = 4 + queueId,
//                   .output_queue = queueId
// task_memcpy.csl:  .queueId = 0,
// task_memcpy.csl:  .queueId = 1,
// task_memcpy.csl:  .queueId = 2,
// task_memcpy.csl:  .queueId = 3,
//
// so memcpyH2D with input_queue = 0 does not collide others
// The D2H uses output_queue = 0
// There should not have any problem with output_queue = 0
// because multiple colors can share the same output_queue
//


param eastChannel:  color = @get_color(4);
param westChannel:  color = @get_color(5);
param northChannel: color = @get_color(6);
param southChannel: color = @get_color(7);

// WARNING: ID 21: reserved (memcpy)
// WARNING: ID 22: reserved (memcpy)
//          ID 23: reserved (memcpy)
param eastWestFin:  local_task_id = @get_local_task_id(25);
param northSouthFin: local_task_id = @get_local_task_id(26);

param eastDataFin:  local_task_id = @get_local_task_id(16);
param westDataFin:  local_task_id = @get_local_task_id(17);
param northDataFin: local_task_id = @get_local_task_id(18);
param southDataFin: local_task_id = @get_local_task_id(19);

param eastWestCtrlFin:  local_task_id = @get_local_task_id(20);
param northSouthCtrlFin: local_task_id = @get_local_task_id(24);

var numChunks: i16;
param chunkSize: i16;

const neighbours = if (@is_arch("wse2")) pattern else (pattern-1);
var buffer = @zeros([directionCount, neighbours, chunkSize]f32);
const dummy = @zeros([1]f32);

param pattern: i16;

param eastRoute: comptime_struct;
param westRoute: comptime_struct;
param southRoute: comptime_struct;
param northRoute: comptime_struct;
param eastPatternId: i16;
param westPatternId: i16;
param southPatternId: i16;
param northPatternId: i16;
param eastSenderCount: i16;
param westSenderCount: i16;
param southSenderCount: i16;
param northSenderCount: i16;

var sendDsd: mem1d_dsd;

const directionCount: i16 = 4;

var recvChunkCounter: i16 = 0;
var sendChunkCounter: i16 = 0;

var clearRecvBufCB: *const fn(i16)void;
var communicateCB: *const fn()void;

const eastBus = @import_module("oned_exch.csl", .{
  .buffer = &buffer,
  .pattern = pattern,
  .chunkSize = chunkSize,

  .pos = 0,
  .dir = EAST,
  .queueId = 0,
  .patternId = eastPatternId,
  .dataFin_task_id = eastDataFin,
  .channel = eastChannel,
  .callback = eastWestFinTask,
  .is_activate_action = true,
  .senderCount = eastSenderCount,
  .ctrlCallback = eastWestCtrlFinTask,
});

const westBus = @import_module("oned_exch.csl", .{
  .buffer = &buffer,
  .pattern = pattern,
  .chunkSize = chunkSize,

  .pos = 1,
  .dir = WEST,
  .queueId = 1,
  .patternId = westPatternId,
  .dataFin_task_id = westDataFin,
  .channel = westChannel,
  .callback = eastWestFinTask,
  .is_activate_action = false,
  .senderCount = westSenderCount,
  .ctrlCallback = eastWestCtrlFinTask,
});

const southBus = @import_module("oned_exch.csl", .{
  .buffer = &buffer,
  .pattern = pattern,
  .chunkSize = chunkSize,

  .pos = 2,
  .dir = SOUTH,
  .queueId = 2,
  .patternId = southPatternId,
  .dataFin_task_id = southDataFin,
  .channel = southChannel,
  .callback = northSouthFinTask,
  .is_activate_action = true,
  .senderCount = southSenderCount,
  .ctrlCallback = northSouthCtrlFinTask,
});

const northBus = @import_module("oned_exch.csl", .{
  .buffer = &buffer,
  .pattern = pattern,
  .chunkSize = chunkSize,

  .pos = 3,
  .dir = NORTH,
  .queueId = 3,
  .patternId = northPatternId,
  .dataFin_task_id = northDataFin,
  .channel = northChannel,
  .callback = northSouthFinTask,
  .is_activate_action = false,
  .senderCount = northSenderCount,
  .ctrlCallback = northSouthCtrlFinTask,
});

var sendCount: i16 = 0;
var recvCount: i16 = 0;

// ****************************************************** //
// *                 PRIVATE FUNCTIONS                  * //
// ****************************************************** //

// This function is called when the program completes communication in any one
// of the east, west, north, and south directions.
fn recvFin() void {
  recvCount += 2;

  // Don't proceed until we've finished communicating in _all_ four directions.
  if (recvCount != directionCount) {
    return;
  }

  recvCount = 0;

  // Each direction's communication module writes to a separate chunk of the
  // buffer, so the following function call performs a sum reduction across all
  // of these chunks.  This enables us to reuse this buffer for the next round
  // of `chunkSize` communication without forcing us to allocate one large
  // buffer for all chunks and for all four directions, which may require more
  // memory than is available at any given PE.
  clearRecvBufCB(@as(i16, recvChunkCounter * chunkSize));

  // The above code multiplies the source data with constants for neighbors in
  // the X and Y dimension, but we still need to multiply with the right
  // constants in the Z dimension.  Here, we keep track of the number of chunks
  // we've received so that we know when to start computing over the Z dim.
  recvChunkCounter += 1;

  // Note the difference in branch predicates below.  We want to continue
  // receiving until we've received `chunkSize` values `numChunks` number of
  // times.  However, the condition for calling `epilog()`, which processes
  // values in the Z dimension, checks whether we've finished _sending_.  This
  // way, we ensure that the _both_ sending and receiving code is fully complete
  // before we begin further processing.  This also ensures that only _one_ of
  // the `recvFin()` or `sendFin()` functions calls the `epilog()` code.
  if (recvChunkCounter != numChunks) {
    // Set the PE to again receive `chunkSize` values from all four directions.
    startReceiving();
  } else if (sendChunkCounter == numChunks) {
    // Remainder tasks after exchanging data in all four direction.
    communicateCB();
  }
}

// Just like the code to receive `chunkSize` elements need to be called for the
// total number of chunks, the sending code is also called multiple times so
// that each call sends `chunkSize` elements to its neighbors.
fn sendFin() void {
  sendCount += 2;

  // Don't proceed until we've finished sending to all four neighbors.
  if (sendCount != directionCount) {
    return;
  }

  sendCount = 0;
  sendChunkCounter += 1;

  // Note the difference in branch predicates below.  We want to continue
  // sending until we've sent `chunkSize` values `numChunks` number of times.
  // However, the condition for calling `epilog()`, which processes values in
  // the Z dimension, checks whether we've finished _receiving_.  This way, we
  // ensure that the _both_ sending and receiving code is fully complete before
  // we begin further processing.  This also ensures that only _one_ of the
  // `recvFin()` or `sendFin()` functions calls the `epilog()` code.
  if (sendChunkCounter != numChunks) {
    startSending(@as(i16, sendChunkCounter * chunkSize));
  } else if (recvChunkCounter == numChunks) {
    // Remainder tasks after exchanging data in all four direction.
    communicateCB();
  }
}

task eastWestFinTask() void {
  @block(eastWestFin);
  recvFin();
}

task northSouthFinTask() void {
  @block(northSouthFin);
  recvFin();
}

task eastWestCtrlFinTask() void {
  @block(eastWestCtrlFin);
  sendFin();
}

task northSouthCtrlFinTask() void {
  @block(northSouthCtrlFin);
  sendFin();
}

fn startReceiving() void {
  eastBus.recvMode();
  westBus.recvMode();
  southBus.recvMode();
  northBus.recvMode();
}

fn startSending(offset: i16) void {
  eastBus.send(@increment_dsd_offset(sendDsd, offset, f32));
  westBus.send(@increment_dsd_offset(sendDsd, offset, f32));
  southBus.send(@increment_dsd_offset(sendDsd, offset, f32));
  northBus.send(@increment_dsd_offset(sendDsd, offset, f32));
}

fn startExchange() void {
  // Reset the chunk counters since we will be exchanging all chunks now.
  sendChunkCounter = 0;
  recvChunkCounter = 0;

  // We first need to put the PEs in receive mode before sending local data.
  // Starts Laplacian receive and multiplies on the fly for all 4 directions
  startReceiving();
  // Sends data from the previous iterations along all 4 directions
  startSending(0);
}

fn getPermutedIdx(patternId: i16, idx: i16) i16 {
  if (@is_arch("wse2")) {
    return patternId - idx + (if (patternId < idx) @as(i16, pattern) else 0);
  } else {
    return patternId - idx + (if (patternId <= idx) @as(i16, pattern-2) else -1);
  }
}

// ****************************************************** //
// *                  PUBLIC FUNCTIONS                  * //
// ****************************************************** //

// communicates the content of send_dsd to all points in the stencil, and receives data from all points in the stencil
// communication happens in a specified number of chunks at a fixed chunk size (module parameter)
// this function takes the following arguments:
//   - send_dsd:           data to be sent, must be at least of length chunkSize
//   - num_chunks:         the number of chunks to be sent
//   - clear_recv_buf_cb:  callback invoked after receiving one chunk of data from each point in the stencil.
//                         takes one arg 'offset' to indicate that the received data chunks are positioned
//                         at [offset, offset+chunkSize] in the sender's send_dsd.
//                         to access data in the receive buffers, use getRecvBufDsd(), getRecvBufDsdByDir(), or getRecvBufDsdByNeighbor().
//                         the total number of invocations of the callback equals numChunks amount of time.
//   - communicate_cb:     callback invoked once after all communication (sending and receiving) is completed.
fn communicate(send_dsd: mem1d_dsd,
               num_chunks: i16,
               clear_recv_buf_cb: *const fn(i16)void,
               communicate_cb: *const fn()void
              ) void {
  sendDsd = send_dsd;
  numChunks = num_chunks;
  clearRecvBufCB = clear_recv_buf_cb;
  communicateCB = communicate_cb;
  startExchange();
}

// sets coefficients that are equal in all directions
// this function takes the following arguments:
//   - coeffs:             coefficients for each stencil arm, of the form [self, self+1, self+2, ..]
//   - self:               indicate if data should be sent to self (since we always send data to self, this effectively sets coeffs[0] = 0.0)
//                         if data is sent to self, it will end up in the east buffer
fn setUniformCoeffs(coeffs: *const [neighbours]f32) void {
  setCoeffs(coeffs, coeffs, coeffs, coeffs);
}

// sets individual coefficients for each cardinal direction
// see setUniformCoeffs() for details
fn setCoeffs(eastCoeffs: *const [neighbours]f32, westCoeffs: *const [neighbours]f32, southCoeffs: *const [neighbours]f32, northCoeffs: *const [neighbours]f32) void {
  eastBus.setCoeffs(eastCoeffs);
  westBus.setCoeffs(westCoeffs);
  southBus.setCoeffs(southCoeffs);
  northBus.setCoeffs(northCoeffs);
}

// get DSD to access receive buffers for all points in the stencil
// can read a total of directionCount * pattern * chunkSize data
// note, that the `pattern` index is out of order
fn getRecvBufDsd() mem4d_dsd {
  return @get_dsd(mem4d_dsd, .{
    .tensor_access = |i,j,k|{directionCount, neighbours, chunkSize} -> buffer[i, j, k]
  });
}

// get DSD to access receive buffers of all points in one specified direction
// can read a total of `pattern * chunkSize` data
// note, that the `pattern` index is out of order
// this function takes the following arguments:
//   - dir                 a direction, one of EAST, WEST, SOUTH, NORTH
fn getRecvBufDsdByDir(dir: direction) mem4d_dsd {
  if (dir == EAST) {
    return @get_dsd(mem4d_dsd, .{
      .tensor_access = |i,j|{neighbours, chunkSize} -> buffer[0, i, j]
    });
  }
  if (dir == WEST) {
    return @get_dsd(mem4d_dsd, .{
      .tensor_access = |i,j|{neighbours, chunkSize} -> buffer[1, i, j]
    });
  }
  if (dir == SOUTH) {
    return @get_dsd(mem4d_dsd, .{
      .tensor_access = |i,j|{neighbours, chunkSize} -> buffer[2, i, j]
    });
  }
  // dir == NORTH
  return @get_dsd(mem4d_dsd, .{
    .tensor_access = |i,j|{neighbours, chunkSize} -> buffer[3, i, j]
  });
}

// get DSD to access receive buffer a given point in the stencil
// can read a total of `chunkSize` data
// note, that the `pattern` index is out of order
// this function takes the following arguments:
//   - dir                 a direction, one of EAST, WEST, SOUTH, NORTH
//   - neighbor            a value from 0 (self) to pattern-1 (furthest point in the stencil)
fn getRecvBufDsdByNeighbor(dir: direction, neighbor: i16) mem1d_dsd {
  const dummyDsd = @get_dsd(mem1d_dsd, .{
    .tensor_access = |i|{chunkSize} -> dummy[i]
  });
  if (dir == EAST) {
    const idx = getPermutedIdx(eastPatternId, neighbor);
    return @set_dsd_base_addr(dummyDsd, @ptrcast([*]f32, &(buffer[0, idx, 0])));
  }
  if (dir == WEST) {
    const idx = getPermutedIdx(westPatternId, neighbor);
    return @set_dsd_base_addr(dummyDsd, @ptrcast([*]f32, &(buffer[1, idx, 0])));
  }
  if (dir == SOUTH) {
    const idx = getPermutedIdx(southPatternId, neighbor);
    return @set_dsd_base_addr(dummyDsd, @ptrcast([*]f32, &(buffer[2, idx, 0])));
  }
  // dir == NORTH
  const idx = getPermutedIdx(northPatternId, neighbor);
  return @set_dsd_base_addr(dummyDsd, @ptrcast([*]f32, &(buffer[3, idx, 0])));
}


comptime {
  @bind_local_task(eastWestFinTask, eastWestFin);
  @bind_local_task(northSouthFinTask, northSouthFin);
  @bind_local_task(eastWestCtrlFinTask, eastWestCtrlFin);
  @bind_local_task(northSouthCtrlFinTask, northSouthCtrlFin);
  @set_local_color_config(eastChannel, eastRoute);
  @set_local_color_config(westChannel, westRoute);
  @set_local_color_config(southChannel, southRoute);
  @set_local_color_config(northChannel, northRoute);
  @block(eastWestFin);
  @block(northSouthFin);
  @block(eastWestCtrlFin);
  @block(northSouthCtrlFin);
}