#!/usr/bin/env cs_python

# Copyright 2023 Cerebras Systems.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from traceback import format_exc
import argparse
from typing import Optional, Tuple, List
import numpy as np
import json
from timings import init, timer, fprint
import struct
import os, signal
import sys
from pathlib import Path

fprint("Starting run.py")
try:
    from cerebras.appliance.pb.sdk.sdk_common_pb2 import MemcpyDataType, MemcpyOrder  # type: ignore
    from cerebras.sdk.client import SdkRuntime  # type: ignore
except ModuleNotFoundError:
    from cerebras.sdk.runtime.sdkruntimepybind import (  # type: ignore
        SdkRuntime,
        MemcpyDataType,
        MemcpyOrder,
    )

fprint("imports OK")


# Read arguments
parser = argparse.ArgumentParser()
parser.add_argument(
    "--name",
    required=False,
    type=str,
    help="the compile output dir",
)
parser.add_argument(
    "-g",
    "--debug",
    required=False,
    action="store_true",
    help="add debug info",
)
parser.add_argument(
    "-o",
    "--out",
    required=True,
    type=str,
    help="location of the output file",
)
parser.add_argument(
    "--xdim",
    required=True,
    type=int,
    help="size of the x dimension",
)
parser.add_argument(
    "--ydim",
    required=True,
    type=int,
    help="size of the y dimension",
)
parser.add_argument(
    "--zdim",
    required=True,
    type=int,
    help="size of the z dimension",
)
parser.add_argument(
    "--fn-name",
    required=True,
    type=str,
    help="name of the function to run",
)
parser.add_argument(
    "--buf-names",
    required=False,
    default=["a", "b"],
    nargs="+",
    help="list of buffer names",
)
parser.add_argument(
    "--wse",
    type=int,
    default=2,
    required=False,
    help="WSE version to target",
)
parser.add_argument(
    "--xdsl-ver",
    default="unknown",
    required=False,
    help="xDSL version used",
)
parser.add_argument(
    "-j",
    "--json-file",
    required=True,
    type=Path,
    help="JSON file with the artifact path generated by compile.py",
)
args = parser.parse_args()
is_wse3 = args.wse == 3

XDIM, YDIM, ZDIM, FN_NAME, BUF_NAMES = (
    args.xdim,
    args.ydim,
    args.zdim,
    args.fn_name,
    args.buf_names,
)

LAUNCH = 0
MEMCPY_DTYPE = MemcpyDataType.MEMCPY_32BIT
MEMCPY_SIZE = 4
MEMCPY_ORDER = MemcpyOrder.ROW_MAJOR
MAX_CHUNK = 2_000_000_000


def read_artifact_path(name: Optional[str], file: Path):
    with timer("read_artifact_path"):
        if name is not None:
            return name
        # Read the artifact_path from the JSON file
        with open(file, "r", encoding="utf8") as f:
            data = json.load(f)
            return data["artifact_path"]


def u16x3tou48(words: Tuple[int, ...]):
    return words[0] + (words[1] << 16) + (words[2] << 32)


def read_time_bufs(runner: SdkRuntime, time_buf_name) -> Tuple[List[int], List[float]]:
    """
    Read timestamps from CS-2 memory following the following layout:

    |  |  |  |  |  |  | #  u16 on CS2
             V          #
    |     |     |     | #  u32 in memcpy
             V          #
    |        |        | #  u48 time stamps

    Returns a list of timestamps in seconds, assuming constant 850MHz clock speed
    """
    time_buf_1d = np.zeros(XDIM * YDIM * 3, np.float32)
    recv_data(runner, time_buf_1d, time_buf_name, zdim=3)
    reshaped = time_buf_1d.reshape((XDIM, YDIM, 3))

    times = []
    cycles = []
    for row in reshaped:
        for col in row:
            # unpack as 6 u16s (little endian
            u16s = struct.unpack("<HHHHHH", col)
            start = u16x3tou48(u16s[:3])
            end = u16x3tou48(u16s[3:])
            # 850MHz
            # 850'000'000 cycles per second
            times.append(((end - start) / 850_000_000))
            cycles.append(end - start)
    return times, cycles


def mkgrid():
    return np.arange(1, XDIM * YDIM * ZDIM + 1, dtype=np.float32) % 1000


def get_buf_syms(runner: SdkRuntime):
    assert len(BUF_NAMES) >= 2
    return [runner.get_id(name) for name in BUF_NAMES]


def assert_int(f: float) -> int:
    out = int(f)
    assert out == f, f"{out = } {f = }"
    return out


def _transfer_data(
    runner: SdkRuntime,
    sym: int,
    buf: np.ndarray,
    transfer_fn,
    *,
    xdim=XDIM,
    ydim=YDIM,
    zdim=ZDIM,
    max_chunk=MAX_CHUNK,
):
    is_send = transfer_fn == runner.memcpy_h2d
    full_buffer = buf
    try:
        start_line = 0
        left_to_send = xdim * ydim * zdim * MEMCPY_SIZE
        line_size = xdim * zdim * MEMCPY_SIZE
        safe_to_send = max_chunk - (max_chunk % line_size)
        while left_to_send > 0:
            send_size = min(safe_to_send, left_to_send)
            left_to_send -= send_size
            ydim = assert_int(send_size / line_size)
            fprint(
                f"{'Sending to' if is_send else 'Receiving from'} ({0};{start_line}) {xdim}x{ydim}x{zdim} ({send_size} bytes, {ydim} lines). Send buffer shape is {buf.shape}"
            )
            buf = full_buffer[0 : assert_int(send_size / MEMCPY_SIZE)]
            transfer_fn(
                *(
                    (
                        sym,  # dest
                        buf,  # src
                    )
                    if is_send
                    else (
                        buf,  # dest
                        sym,  # src
                    )
                ),
                0,  # starting x coord
                start_line,  # starting y coord
                xdim,  # width
                ydim,  # height
                zdim,  # elems_per_pe
                streaming=False,
                data_type=MEMCPY_DTYPE,
                order=MEMCPY_ORDER,
                nonblock=False,
            )
            full_buffer = full_buffer[assert_int(send_size / MEMCPY_SIZE) :]
            start_line += ydim
            fprint(
                f"Successfully {'sent' if is_send else 'received'} {send_size} bytes ({ydim} lines). {left_to_send} bytes left to {'send' if is_send else 'receive'}. Starting next line at {start_line}"
            )
    except RuntimeError:
        print(
            f"Got a runtime error: {sym = } {buf.shape = }; {xdim = }; {ydim = }; {zdim = }"
        )
        raise


def send_data(
    runner: SdkRuntime,
    sym: int,
    buf: np.ndarray,
    *,
    xdim=XDIM,
    ydim=YDIM,
    zdim=ZDIM,
    max_chunk=MAX_CHUNK,
):
    return _transfer_data(
        runner,
        sym,
        buf,
        runner.memcpy_h2d,
        xdim=xdim,
        ydim=ydim,
        zdim=zdim,
        max_chunk=max_chunk,
    )


def recv_data(
    runner: SdkRuntime,
    buf: np.ndarray,
    sym: int,
    *,
    xdim=XDIM,
    ydim=YDIM,
    zdim=ZDIM,
    max_chunk=MAX_CHUNK,
):
    return _transfer_data(
        runner,
        sym,
        buf,
        runner.memcpy_d2h,
        xdim=xdim,
        ydim=ydim,
        zdim=zdim,
        max_chunk=max_chunk,
    )


def main(is_sim: bool):
    fprint("Starting main")
    #    dirname: str = args.name
    fprint(
        f"{XDIM = }, {YDIM = }, {ZDIM = }; name = {args.name}, {is_sim = }, buffer names = {BUF_NAMES}"
    )
    with timer("mkgrid"):
        grid = mkgrid()

    with timer("construct SDK"):
        runner = SdkRuntime(
            read_artifact_path(args.name, args.json_file),
            suppress_simfab_trace=not args.debug,
            simulator=is_sim,
        )
    if not is_sim:
        with timer("start"):
            runner = runner.__enter__()



    try:

        fprint("Constructed" + (" " if is_sim else " and started ") + "runner")
        with timer("get IDs"):
            time_buf_name = runner.get_id("timers")
            *inp_bufs, out_buf = get_buf_syms(runner)
            assert all(name is not None for name in inp_bufs) and out_buf is not None
        fprint("Got symbols")

        if is_sim:
            with timer("load+run"):
                runner.load()
                runner.run()
            fprint("Started runner")

        with timer("main compute") as host_time:
            with timer("send data"):
                for buf_sym in (*inp_bufs, out_buf):
                    send_data(runner, buf_sym, grid)
            fprint("sent data")

            with timer("run function"):
                runner.launch(FN_NAME, nonblock=False)

            fprint("Compute done")
            with timer("create zeros"):
                z_1d = np.zeros(XDIM * YDIM * ZDIM, np.float32)

            with timer("receive data"):
                recv_data(runner, z_1d, out_buf)
                times, cycles = read_time_bufs(runner, time_buf_name)
            fprint("Received data")
    finally:
        with timer("call stop"):
            if is_sim:
                runner.stop()
            else:
                runner.__exit__(*sys.exc_info())


    fprint("Runner stopped")
    z_1d = z_1d.reshape([YDIM, XDIM, ZDIM]).transpose(1, 0, 2).ravel()

    with timer("getting stats"):
        sum = np.sum(z_1d)
        min = np.min(z_1d)
        max = np.max(z_1d)
        nans = np.count_nonzero(np.isnan(z_1d))
        posinfs = np.count_nonzero(np.isposinf(z_1d))
        neginfs = np.count_nonzero(np.isneginf(z_1d))
        std = np.std(z_1d)

        time_mean = np.mean(times)
        time_median = np.median(times)
        time_std = np.std(times)
        time_min = np.min(times)
        time_max = np.max(times)

        cycle_mean = np.mean(cycles)
        cycle_median = np.median(cycles)
        cycle_std = np.std(cycles)
        cycle_min = np.min(cycles)
        cycle_max = np.max(cycles)

    with timer("write out data"):
        with open(args.out, "w") as out, np.printoptions(threshold=0x7FFFFFFFFFFFFFFF):
            fprint(f"xdsl-ver = {args.xdsl_ver}", file=out)
            fprint(f"{sum = }", file=out)
            fprint(f"{min = }", file=out)
            fprint(f"{max = }", file=out)
            fprint(f"{std = }", file=out)
            fprint(f"{nans = }", file=out)
            fprint(f"{posinfs = }", file=out)
            fprint(f"{neginfs = }", file=out)

            fprint(f"{time_mean = }", file=out)
            fprint(f"{time_median = }", file=out)
            fprint(f"{time_std = }", file=out)
            fprint(f"{time_min = }", file=out)
            fprint(f"{time_max = }", file=out)

            fprint(f"{cycle_mean = }", file=out)
            fprint(f"{cycle_median = }", file=out)
            fprint(f"{cycle_std = }", file=out)
            fprint(f"{cycle_min = }", file=out)
            fprint(f"{cycle_max = }", file=out)

            fprint(f"host_time = {host_time.time}", file=out)

    fprint("All done")


if __name__ == "__main__":
    try:
        is_sim = args.name != None
        init(f"{FN_NAME}-{XDIM}-{YDIM}-{ZDIM}{'-(SIM)' if is_sim else ''}")
        with timer("main"):
            main(is_sim)
    except:
        fprint("Error:\n", format_exc(), sep="")
    finally:
        os.kill(os.getpid(), signal.SIGTERM)
